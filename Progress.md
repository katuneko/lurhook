* [x] **目的（改善の狙い）:** コードベースの見通しを良くし拡張しやすくするため、機能ごとにモジュールを分離する。
  **対象（構造体・ファイル）:** プロジェクト全体（Workspace設定、`crates/ui`, `crates/fishing`, `crates/mapgen` など各サブクレート）
  **内容:** 現行のコードを機能別に整理し、UI描画、マップ生成、AIロジック等を別クレート/モジュールに分割する。例えばマップ生成処理は`mapgen`クレート、魚のAIやスポーン処理は`ecology`クレート、釣りミニゲームの張力管理は`fishing`クレート、描画関係は`ui`クレートに切り出す。それぞれのAPIを設計し、`game-core`から各モジュールを呼び出す形にリファクタリングする（もしくは新規実装時に適用する）。これによりコードの見通しを確保し、機能追加時の影響範囲を限定できる。各クレートの`init()`関数で初期化ログを出力するなどして、分離が正しく機能することを確認する。

* [x] **目的（改善の狙い）:** 毎プレイ新鮮な地形で探索できるよう、ローグライクなランダムマップ生成を実装する。
  **対象（関数・ファイル）:** `crates/mapgen/src/lib.rs`（例: `generate`関数）
  **内容:** BSPアルゴリズムとパーリンノイズを組み合わせ、海域マップ（デフォルト80×25ターミナルサイズ）をランダム生成する。島（陸地）や浅瀬・深海タイルをランダム配置し、各タイルに深度情報（浅瀬/深海フラグ）を付与する。`generate(seed, width, height)`関数で同じシード値なら同じ地形が生成されるようにし、海と陸の構成バランスを調整する。生成結果を保持する`Map`構造体には、タイル種別配列と便利関数（例: 座標→インデックス変換`idx()`やタイルの深度取得`depth()`）を用意する。これにより毎回異なるマップでゲームを開始できるようにする。

* [x] **目的（改善の狙い）:** プレイヤーがマップ上を自由に探索できるようにし、視界外への移動を防止する。
  **対象（関数・構造体）:** プレイヤー位置管理（例: `game-core`内の`Player.pos`）、入力処理（`handle_input`関数）
  **内容:** 矢印キーまたはテンキー/viキーの入力に応じてプレイヤー（`@`）を8方向に1マス移動させるロジックを実装する。移動時には現在の`Player.pos`を更新し、カメラ座標を計算してマップをスクロールさせる（プレイヤーが画面中央付近に表示されるように、`camera()`でオフセット計算）。マップ端ではそれ以上進まないよう境界チェック（座標を0～マップ幅/高さ-1にClamp）を行う。移動後の位置が陸地/水域/深海のいずれかであっても、境界外に出ないことを保証する。これにより、プレイヤーは生成されたマップ全体を隅々まで探索できる。

* [x] **目的（改善の狙い）:** ターン制のゲームループを導入し、一手ごとに世界が進行するクラシックローグライクのテンポを実現する。
  **対象（関数・構造体）:** ゲームループ実装（例: `LurhookGame.tick`）、時間管理変数（`turn`カウンタ等）
  **内容:** ゲームステートにターン経過処理を実装し、基本ループを「**入力受付 → 状態更新 → 描画**」の順で回す。具体的には`GameState::tick()`内で、プレイヤー入力が発生した場合のみ`advance_time()`により`turn`をインクリメントし、各システムの更新を行う（探索モードなら魚の行動更新、釣りモードなら張力計算など）。入力がない間は`turn`を進めずゲーム内時間を止める。この仕組みによりキー入力ごとに1ターン経過し、プレイヤーが考える間は時間停止するクラシックローグライクのペースを再現する。最後に`ctx.cls()`で画面をクリアし、新しいフレームを描画する。

* [x] **目的（改善の狙い）:** マップ上に魚を発生させ、生態系をシミュレートすることで探索要素に動的な発見を加える。
  **対象（関数・構造体）:** 魚管理ロジック（例: `crates/ecology/src/lib.rs` の`spawn_fish_population`, `update_fish`関数）
  **内容:** ゲーム開始時に水域タイル上に魚（エンティティ）をスポーンさせる処理を実装する。`FishType`データ（JSONからロード）には各魚の出現レア度`rarity`や強さ`strength`、生息深度範囲`min_depth`/`max_depth`が含まれるため、これらに基づきランダムにスポーン位置と種類を決定する。水タイル座標リストから深度条件を満たす候補を絞り込み、レア度に応じた重み付き乱数で魚種を選択して配置する。また、毎ターン魚一覧を更新し、簡易AIで移動させる`update_fish`を実装する。各魚はランダムな方向へ1マス（夜間は後述の日照判定で2マス）移動し、移動先が海であれば位置を更新する。さらに同種の魚が一定半径内にいる場合はその方向へ微妙に移動を補正し、群れ行動を模倣する（スクーリング効果）。境界でマップ外に出そうになればClamp処理で留め、陸には上がらないようにする。これによりマップ上を魚がゆっくり泳ぎ回り、生態系に変化が生まれる。

* [x] **目的（改善の狙い）:** 潮の流れや昼夜の変化を取り入れ、時間経過による環境変化と戦略性を追加する。
  **対象（関数・変数）:** 時間管理（例: `LurhookGame.time_of_day`、`turn`）、魚移動AI（`update_fish`内の日中判定）、潮流適用関数（例: `apply_current`）
  **内容:** ゲーム内時間を朝→昼→夕→夜のサイクルで表現し、昼夜で生物の挙動が変化するようにする。具体的には`turn`経過に応じて一定ターンごとに`time_of_day`を次のフェーズに更新し（例: 10ターンで1区切りとして朝→昼…と循環させる）、夜間には魚の移動速度を上げる（1ターンに2マス移動させる）。同時に**潮流**の概念を導入し、例えば20ターンごとに潮の流れが東→西→東…と交互に切り替わるようにする。`current_drift()`関数で現在の潮流ベクトル（例: 東向きなら`Point(1,0)`）を計算し、毎ターン魚更新時に`apply_current`で全魚の位置にそのベクトルを加算する。潮流適用時も境界外に出ないようClampし、移動先が水タイルの場合のみ位置を更新する。これによりプレイヤーは時間帯や潮の状況に応じて魚の動きを予測・利用できるようになり、ゲーム性が深まる。

* [x] **目的（改善の狙い）:** ランダムイベントにより探索中のサプライズ要素やリソース獲得機会を増やし、単調さを緩和する。
  **対象（関数・構造体）:** 地形イベント処理（例: `game-core`内の移動後イベント判定ロジック）、プレイヤー状態（HPなど）
  **内容:** プレイヤーの現在地やエリアに応じて発生するランダムイベントを実装する。例えばプレイヤーが**陸地タイル**に到達した際、一定確率でイベントを発生させる: ひとつは**休息イベント**で、その場で小休止しHPを少量回復させる（例: HPを最大値の10%程度回復）か、数ターンの間時間経過をスキップする処理を行う。また別の可能性として**アイテム発掘イベント**を用意し、漂着物から食料や装備アイテムを入手できるようにする（後述の携行食や新しい釣り道具を`player.items`に追加しログに通知）。深海エリアでは、探索中に**嵐イベント**が発生する場合がある。嵐イベントでは突然周囲が暗くなり視界が悪化する（後述の視界制限効果を一時的に強制適用）ほか、荒波の演出としてログに「嵐に見舞われている！」等のメッセージを表示する。嵐は例えば3ターン程度持続し、その間プレイヤーの視界半径が極端に狭まるか、次に述べるハザード発生率が一時的に上昇するなどの影響を与える。これらの地形イベントをランダムに組み込むことで、単なる移動中にも思いがけない展開やメリット（休息・アイテム獲得）が生まれるようにする。

* [x] **目的（改善の狙い）:** プレイヤーの生存要素を導入し、探索にリスクとリソース管理の要素を加える。
  **対象（構造体）:** プレイヤーステータス（例: `game-core::types::Player` 構造体）
  **内容:** プレイヤーに\*\*HP（体力）\*\*の概念を追加する。`Player`構造体に`hp: i32`フィールドを新設し、ゲーム開始時に最大HPで初期化する。今回の設計では最大HPを例えば10としておき（後のバランス調整で変更可能）、HPが0になるとゲームオーバー（探索脱落）となるようにする。UI上ではステータスパネルにHPを表示（ハート記号や数値で残量を示す）し、プレイヤーがダメージを受けるたびに値を減少させていく（負数にはならないようClamp）。ダメージ処理やゲームオーバー判定はHP減少時に行い、0になった時点でログに「力尽きた…」などのメッセージを出してゲームループを終了するフラグを立てる。これによりプレイヤーはHP管理を意識した行動が求められる。

* [x] **目的（改善の狙い）:** 空腹度システムを導入し、探索と時間経過にリソース管理の緊張感を持たせる。
  **対象（構造体・UI）:** プレイヤーステータス（`Player.hunger`フィールド）、UIステータスパネル描画（`UIContext.draw_status`）
  **内容:** プレイヤーに**満腹度（空腹度）**を導入する。`Player`構造体に`hunger: i32`（0～100）を追加し、ゲーム開始時に100で初期化する。毎ターン経過時に`hunger`を1減少させ（難易度によって減少量スケール、Normalでは1/ターン）、値が0になると**餓死状態**となり、以降はターン経過ごとにHPが1ずつ減少する。この連動により空腹の放置が死亡に直結するよう調整する。UIのステータスパネルに満腹度ゲージを追加し、残量に応じて色分け表示する（例えば`hunger > 60`なら緑、`>30`なら黄、それ以下は赤で表示）。ゲージ描画には`hunger_bar_string`関数で`#`と`-`からなるバー文字列を生成し、`draw_status`内で「Food: \[#####-----]」のように描画する。満腹度が0のときはHP減少効果を発動する旨をログ通知し、逆に十分満腹であれば戦闘力に影響する等の要素は今回は設けない（シンプルにHP減少ペナルティのみ）。この空腹度システムにより、プレイヤーは探索中に適度に食料を補給しないと徐々に衰弱していく緊張感が生まれる。

* [x] **目的（改善の狙い）:** プレイヤーが満腹度を回復する手段を段階的に追加し、ゲーム開始直後から終盤まで食料管理の戦略を深める。
  **対象（関数・データ）:** インベントリ操作（`activate_selected_item`や後述のUI処理）、地形イベント処理、アイテムデータ（`items.json`）
  **内容:** 空腹度を回復する以下の手段を実装する（**段階的に開放**していく想定）：

  1. **生魚をそのまま食べる** – プレイヤーがインベントリに持っている魚を選択して生食できるようにする。インベントリUI上で魚アイテムを選択しEnter確定で実行し、該当の魚を削除して満腹度を+20%回復させる（例えば`hunger`+20）。生食によるペナルティ（例: 軽いHP減少）は今回は無しとする。
  2. **簡易調理して食べる** – 陸地の**焚き火イベント**時に魚を調理できるようにする。プレイヤーが陸上にいる状態で専用コマンド（例: `Cook`）を実行すると、インベントリから魚を1匹消費し、満腹度を+40%回復、さらにHPも少量（例: +2）回復する。実装としては、地形イベント処理で陸上にいるか確認後、`Player.inventory`から魚を取り出し、満腹度・HPを増加、ログに「魚を調理して食べた。」等を追加する。魚未所持の場合は「調理できる魚がない」旨をログ表示する。
  3. **携行食を摂取する** – マップ上のイベント（例: 漂着物）やショップ機能追加時に**缶詰**などの携行保存食アイテムを入手できるようにする。アイテムデータ`items.json`に`kind: Food`のアイテム（例: `"CannedFood"`）を追加し、`bite_bonus`等は0で`reel_factor`も1.0とするが`hunger`回復量60%相当の効果を持たせる。プレイヤーがこれを所持している場合、インベントリUIで選択しEnterで食べることが可能（実装は`activate_selected_item`内で`ItemKind::Food`の場合に`hunger`を+60しアイテム削除）。使用時は「携行食を食べた。」などログを追加する。以上の手段をゲーム進行に合わせて順次導入することで、序盤は釣った魚の生食、中盤以降は調理、さらに遠征先での携行食確保と、段階的に戦略が広がる。

* [x] **目的（改善の狙い）:** 探索時にランダムな危険イベントを導入し、緊張感とリスク管理要素を高める。
  **対象（構造体・関数）:** ハザード管理（`game-core::types::Hazard`構造体、`update_hazards`処理）、難易度パラメータ（`HAZARD_CHANCE`定数 等）
  **内容:** ターン経過時に一定確率で**ハザード（危険イベント）**が発生する仕組みを実装する。`HAZARD_CHANCE`を基準確率（例: 8%）とし、現在エリアや難易度に応じて確率を補正する（深海エリアほど高リスク、Hardモードでは2倍など）。ハザード発生がトリガした場合、`Hazard`エンティティを生成しプレイヤー位置に配置する。Hazardは`turns`（持続ターン数）を持ち、その間毎ターンプレイヤーに影響を及ぼす。例えば接触した**敵性生物**（クラゲやサメを想定）や落雷などをハザードとして表現し、各ターン以下の効果を与える: **HPダメージ**（1減少）と**装備損傷**として釣り糸の耐久度`line`を一定量削る（例: 15減少）。実装としては`update_hazards()`関数内で`self.hazards`リストを走査し、各HazardについてプレイヤーHPを`hp -= HAZARD_DAMAGE`、釣り糸耐久を`line = max(line - LINE_DAMAGE, 0)`減少させる。`line`が0になった場合は「釣り糸が切れた！」等ログを追加し、以後釣りが困難になる演出を行う。Hazardの`turns`をデクリメントし0になればリストから除去する（ハザードの終了）。また、ハザード発生時にはログに「**!** 敵性生物が襲ってきた！」等のメッセージを表示し、マップ上に`!`アイコンで表示する。例えばハザードの種別によっては持続1ターンの一過性ダメージ（クラゲに刺された）や、複数ターン持続する嵐（上記Stormイベントと連動し視界不良と継続ダメージ）などバリエーションを持たせることも可能。これにより常に不測の危険を念頭に行動するスリルが生まれる。

* [x] **目的（改善の狙い）:** 釣り糸を投げ込むアクションと狙いを定める操作を実装し、釣りミニゲームの導入準備を行う。
  **対象（関数・構造体）:** 入力処理（例: `handle_input_key`内のCastキー処理）、ゲームモード管理（`GameMode::Aiming` 遷移）、UI表示（`draw_map`ターゲット描画）
  **内容:** プレイヤーが釣りを開始できるよう、キャスト（釣り糸を投げる）操作を実装する。まずキーバインドとして、例えば`c`キー押下で**キャストモード**に入るようにする。`GameMode`を`Exploring`から`Aiming{ target: player.pos }`に切り替え、UIレイアウトも`UILayout::Fishing`に変更する（釣りモード用の画面レイアウトに変更）。キャストモード中はプレイヤーキャラクタは動かず、代わりに矢印キー入力で**キャスト位置**ターゲットを動かせるようにする。ターゲットは画面上に`*`アイコンで表示し、プレイヤーからの直線上に移動させる（上下左右斜めに動かし、マップ境界内にClampする）。プレイヤー入力で目標位置が決まったら、再度`c`キー（またはEnterキー）でキャスト確定（釣り糸投入）とする。キャスト確定時にはログに「Casting...」を追加し、プレイヤー位置から目標地点までの直線経路を算出して`self.cast_path`に保持する（ブレスンハムの直線アルゴリズムで座標列を取得するメソッド`line_path`を実装）。その後ゲームモードを`GameMode::Fishing{ wait: n }`に遷移させ、nターンの待機時間を設定する（例: 2ターン程度）。この待機は糸を垂らして魚が食いつくのを待つ演出で、`tick()`更新内で`wait`が0になるまで経過させる。また、キャスト中は釣り糸の**飛行軌跡アニメーション**を表示する。ループで`cast_path`上の座標を順次描画し、投げ込み途中の位置には`*`、最終目標地点には`o`（着水の波紋を表現）を表示する。これは`cast_step`というインデックスを毎ターンインクリメントすることで実現し、`cast_step`未満の経路を描画、最後に`cast_path`をクリアする。これらにより、プレイヤーは狙いを定めて釣り糸を投げ込み、視覚的にもわかりやすい演出で釣りを開始できるようになる。

* [x] **目的（改善の狙い）:** 魚が掛かった際の釣りミニゲーム（テンションバーによる綱引き）を実装し、プレイヤーの操作によって釣果が決まるインタラクティブな要素を提供する。
  **対象（関数・構造体）:** 釣りミニゲーム管理（例: `fishing::TensionMeter`構造体と`update`関数）、ゲームモード遷移（`GameMode::Fishing`継続処理）
  **内容:** キャスト後の待機ターンが経過したら、自動的に魚のバイト（食いつき）判定を行いミニゲームを開始する。まず、釣り糸の落下地点に対応する水深タイル情報とプレイヤーのルアー効果`bait_bonus`をもとに**バイト確率**を算出する（例: 深度が魚の好適範囲内ならベース確率高めに設定し、`bait_bonus`を加算）。乱数ロールにより魚が掛かった場合はログに「Hooked a fish!（魚が掛かった！）」を出力する。魚が掛からなかった場合は「The fish got away...（魚は逃げた…）」とログを出し、ゲームモードを探索状態に戻して釣りを終了する。魚が掛かった場合、**テンションメーター**を初期化する: `TensionMeter`構造体を生成し、魚の強さ`strength`やファイトスタイル`fight_style`、現在プレイヤーが装備中のリール効果`reel_factor`を設定する。さらに後述の装備ボーナス（ロッドの張力補正`tension_bonus`）を最大テンション値に加算する。こうして`self.meter`に格納したら、以降ゲームは`GameMode::Fishing`のまま毎ターン**張力バーの更新**を行う。各ターン、内部フラグ`self.reeling`（プレイヤーがリールを巻いているか）を参照しつつ`TensionMeter.update(reel: bool)`を呼び出し、テンション値を増減させる。`self.reeling`は入力処理で例えば`r`キーが押されていればtrueにセットされ、押されなければfalseのままとして区別する。テンション更新後の戻り値`MeterState`に応じて以下の分岐処理を行う:

  * **Ongoing（継続）**: まだ勝負は続いている。この場合テンションメーターを`self.meter`に戻して次のターンへ持ち越す。ゲームは引き続きFishingモードを維持。
  * **Success（成功）**: 魚を釣り上げることに成功。`self.meter`をNoneにし、魚の情報を取得してプレイヤーのインベントリ（魚リスト）に追加する。今回はシンプルに最初に掛かった魚1匹のみを捕獲とし、ログに「Caught a fish!（魚を捕まえた！）」を表示する。さらに図鑑（後述のCodex）に魚IDを記録し、エリア進行判定（後述）を呼び出す。最後にゲームモードを探索に戻し、UIレイアウトも`Standard`に戻す。
  * **Broken（糸切れ）**: テンションが上限を超えて釣り糸が切れた状態。ログに「Line snapped!（糸が切れた！）」を出し、プレイヤーの`line`耐久度を15減少（下限0）させる。残耐久が0になった場合「Your line is ruined.（釣り糸はボロボロだ）」とログ表示し、以降の釣り成功率が大幅に下がる（または釣り不可になる）ペナルティとする。ゲームモードとUIは探索状態に戻す。
  * **Lost（逃げられ）**: ラインのテンションが完全にゼロになり魚が逃げてしまった状態（糸を緩めすぎたペナルティ）。ログに「The fish escaped!（魚に逃げられた！）」と表示し、ゲームモード/レイアウトを探索に戻す。
    テンションの現在値と最大値は毎フレームUI上部に簡易バー表示し、`UIContext.draw_tension`で描画する（Fishingモード時のみ）。このバーは`[#****----]`のように残り耐久を視覚化し、リアルタイムに増減させてプレイヤーに緊張感を与える。以上の実装で、魚との綱引きミニゲームが完成し、プレイヤーの操作と判断で釣果が決定するようになる。

* [x] **目的（改善の狙い）:** 魚ごとに異なる引きの強さやパターンを設定し、釣りミニゲームのバリエーションと奥深さを増す。
  **対象（データ・ロジック）:** 魚データ（`assets/fish.json`内に新フィールド追加）、テンションメーター更新処理（`TensionMeter.update`）
  **内容:** 各魚種に**ファイトスタイル**属性を持たせ、テンションの増減パターンが変化するようにする。`FishType`に列挙型`FightStyle`フィールドを追加し（Aggressive/Endurance/Evasiveの3種）、データ上で魚ごとに設定する（例: 大型魚はAggressive、小型魚はEvasive）。`TensionMeter.update()`内で魚の`style`に応じた挙動分岐を実装する: Aggressive（獰猛）なら毎ターンのテンション上昇量が大きく不規則（例: `strength * 2`ずつ一気に上昇）、Endurance（持久型）なら釣り上げるまでのターン数（duration）が長い代わりに後半は勢いが落ちる（残りターンが少なくなると上昇量を半減）、Evasive（逃げ足速い）なら糸のテンションが少しでも緩むとすぐ逃げる（テンションが閾値以下なら即ゼロにリセット）。これらのロジックはすでにテンションメーターのupdate関数内に組み込まれている（Aggressive/Endurance/Evasiveに対するマッチ分岐）ので、データからスタイルを設定して正しく適用されるようにする。さらに、**テンションゼロ時のペナルティ**（Lost扱い）もEvasive型で発生しやすくなるため、既に組み込まれているテンション0判定（before > 0 かつ tension == 0 の場合Lost）を活用する。これにより魚種ごとに手応えが変わり、プレイヤーは相手の特徴に応じてリール操作を調整する必要が出てくる。

* [x] **目的（改善の狙い）:** 極めて稀な巨大魚やボス的存在を導入し、ゲームの目標やコレクション要素を強化する。
  **対象（データ・ロジック）:** 魚データ（`FishType.legendary`フラグ）、魚スポーン・AI処理（`spawn_fish_population`, `update_fish`）、釣りミニゲーム演出
  **内容:** **レア/ボス魚**を実装する。`FishType`に`legendary: bool`フラグを追加し、特定の魚種に`legendary: true`を設定する（JSONデータで指定）。レア魚は極低確率でスポーンするようにし、`spawn_fish_population`で魚種選択時に`legendary`フラグを考慮して出現率を極小に設定する。また、スポーンしたレア魚は通常魚と挙動を変える。例えば`update_fish`内で`if fish.kind.legendary { speed += 1 }`として移動速度を他より速くし、追尾AIを強化する（プレイヤーに近づきやすくして出会いやすくするなど）。釣りミニゲーム中もレア魚なら特別な演出を行う。例えばファイト開始時にログに「伝説の魚が掛かった！！」と特別なメッセージを出したり、テンションバーの色を変えてプレッシャーを演出する。またレア魚は非常に強い（`strength`大）ためテンション上昇が急激で糸切れリスクが高いので、慎重なリール操作が必要になる。捕獲に成功した場合はログに「伝説の魚を釣り上げた！」とハイライトし、通常魚より高いスコアや報酬を与える仕組みにする（現状スコア概念がなければ代わりに図鑑で特別扱いする）。さらにレア魚固有の**実績**や称号を用意できれば尚良いが、まずは内部的に図鑑へ記録し、フラグを保存しておく（Steam実績など外部連携する場合に備えJSON保存）。このようにボス的存在を作ることで、プレイヤーの目標が明確化しリプレイ性が向上する。

* [x] **目的（改善の狙い）:** 釣り具（ロッド・リール・ルアーなど）の種類を増やし、性能差をデータ駆動で管理できるようにする。
  **対象（データ・構造体）:** アイテムデータ定義（`assets/items.json`）、`data::ItemType`構造体、プレイヤー装備フィールド（`Player.rod/reel/lure`）
  **内容:** 複数の釣り道具アイテムを導入し、装備によって釣りの性能が変化する仕組みを実装する。まず`ItemType`構造体にパラメータを定義済み（例: `tension_bonus`張力上限補正、`reel_factor`巻き取り効率、`bite_bonus`バイト確率ボーナス）なので、`assets/items.json`に各種アイテムを記述する。例として: **ロッド**（釣り竿）数種は`ItemKind::Rod`で定義し、丈夫なロッドほど`tension_bonus`が高い値になるよう設定。**リール**は`ItemKind::Reel`で定義し、上位のリールほど`reel_factor`（リール巻取り倍率）が大きくなるようにする。**ルアー/餌**は`ItemKind::Lure`で、特定の魚を引き寄せやすい`bite_bonus`や出現率補正を持たせる（汎用的には`bite_bonus`で全体バイト率向上として扱う）。ゲーム開始時に初期装備をプレイヤーに持たせ（例: `Player.rod`に初期ロッドを設定）、他の道具は探索中のイベント（宝箱やショップ）で`Player.items`に追加取得できるようにする。装備の効果反映はすでに釣りロジック側で行っており、`tension_bonus`はテンションメーター初期化時に最大値へ加算、`reel_factor`はテンションメーター計算に影響、`bite_bonus`はバイト確率算出に使用している。装備変更の実装として、プレイヤーがインベントリ上で装備アイテムを選択しEnterを押すと、対応するスロット（rod/reel/lure）をそのアイテムに差し替える。`activate_selected_item`関数内でItemKindごとに現在の装備を外して持ち物に戻し、新しい装備をセットする処理を記述する。例えばRodなら`Player.rod`を更新し、古いRodを`items`リストに戻す。そして`Player.tension_bonus`等のステータス値も新装備の値に更新する。同様にReel, Lureも処理し、Foodの場合は消費処理となる。以上により、装備品コレクションと戦略的な付け替え要素が生まれ、プレイヤーは状況に応じて適切な道具を選択する楽しみが増える。

* [x] **目的（改善の狙い）:** インベントリ画面を使いやすく改善し、所持アイテムや魚の管理・利用が直感的にできるようにする。
  **対象（関数・UI）:** インベントリ表示処理（`UIContext.draw_inventory`）、選択操作ロジック（`inventory_cursor`と`activate_selected_item`関数）
  **内容:** `i`キー押下で**インベントリ画面**に入り、手持ちアイテム一覧を表示・操作できるよう実装する。まず`UIContext.set_layout(Inventory)`でインベントリ用レイアウトに切り替え、画面にアイテムリストを描画する。`draw_inventory`関数ではタイトル「Inventory」を中央に描き、その下に所持アイテムの名前リストを表示する。表示順は装備/消費系アイテム(`Player.items`)と捕獲した魚(`Player.inventory`)をまとめたリストとし、選択中の項目には`"> "`のカーソルを付与する。矢印キー上下で`inventory_cursor`を増減し選択行を移動できるよう、入力処理を実装する。リストの範囲を超えないよう境界チェックもし、アイテム増減で選択インデックスが不正になった場合は補正する。Enterキー押下で現在選択中のアイテムを**使用/装備**する処理を`activate_selected_item`関数内に実装する。ItemKind別の挙動は前述の通りで、Rod/Reel/Lureなら装備切替、Foodなら消費して満腹度回復、魚なら生食して満腹度回復となるように分岐する。使用後はリストから該当アイテムを削除し、必要なら選択位置`inventory_cursor`を調整する。また、インベントリが空の場合は`(empty)`と表示するよう`inventory_strings`生成時に対応する。以上の改修によって、プレイヤーはインベントリ画面上で直感的にアイテムや捕獲した魚を選択・利用できるようになり、UI/UXが大きく向上する。

* [x] **目的（改善の狙い）:** 深海エリアでの視界を制限し、探索難易度と雰囲気を高める。
  **対象（関数・ロジック）:** 視界判定関数（例: `LurhookGame.is_visible`）、マップ描画処理（`draw_map`内のタイル描画部分）
  **内容:** プレイヤーの視界範囲を計算し、その範囲外のタイルを暗く描画する処理を実装する。特に**深海エリア**では視界半径を狭く（例: 半径5マス）設定し、深い闇の中を探索している雰囲気を演出する。実装としては`LurhookGame.is_visible(pt)`のような関数で、プレイヤー位置`player.pos`とタイル座標`pt`のマンハッタン距離またはユークリッド距離を計算し、一定値以内ならtrue（可視）、外ならfalse（不可視）を返すようにする。深海エリアではその閾値を小さく設定し、逆に沿岸部では視界制限を緩和するなどエリアによって動的に半径を変更できるようにする。`draw_map`描画時に各タイルについて`is_visible`結果を参照し、見えないタイルはカラーを暗色に乗算して描画する（例えば元の色に0.4倍の係数を掛けて暗くする）。現在の実装では常に`visible=true`としている箇所を、この判定結果で切り替えるよう修正する。嵐イベント中も一時的に視界半径をさらに縮小する場合は、この関数内で`storm_turns`を参照して閾値を強制的に短くする処理を加える。これにより、深海ではプレイヤーの周囲数マスしか明瞭に見えず、それ以外は暗闇に包まれるため、緊張感と探索難易度が上昇する。

* [x] **目的（改善の狙い）:** ゲーム操作方法を明示し、初見プレイヤーが戸惑わずに遊べるようヘルプ画面を追加する。
  **対象（関数・UI）:** ヘルプ表示処理（`UIContext.draw_help`）、入力管理（F1キー押下処理、初回起動時フラグ）
  **内容:** F1キーでトグル表示できる**ヘルプ画面**を実装する。`UIContext.draw_help`関数に操作説明テキストを用意し（例: "Controls:", "矢印/viキー: 移動", "c: 釣り糸を投げる", "r: リールを巻く", "i: インベントリ", "F1: ヘルプ切替", "Esc/Q: 終了" 等）、`Help`レイアウト時にそれらを画面中央に表示する。ゲーム中にF1キーが押されたら`UIContext.set_layout(Help)`と通常レイアウトを切り替え、ヘルプテキストをオーバーレイ表示/非表示する実装を`handle_input`内に追加する（既存のヘルプレイアウト切替処理を利用）。また、ゲーム開始時（新規プレイ時）にはチュートリアルとして自動で一度ヘルプ画面を表示する。初期化処理で`game.ui.set_layout(UILayout::Help)`とし、プレイヤーが任意のキーを押すまでヘルプ表示から進行しないようにする。このようにすることで、新規プレイヤーはゲーム開始直後に操作方法を確認でき、その後もF1でいつでも参照可能となる。

* [x] **目的（改善の狙い）:** プレイ中に設定を変更できるメニューを設け、ユーザビリティとアクセシビリティを向上させる。
  **対象（関数・UI）:** オプションメニュー表示（`UIContext.draw_options`）、入力設定構造体（`InputConfig`）
  **内容:** ゲーム内で**設定変更メニュー**（Options）を開けるようにする。例えばEscキーや`O`キー押下で`UIContext.set_layout(Options)`に切り替え、オプション項目一覧を表示する。`draw_options`関数には現在の各設定値（色覚モード、音量、キャストキー配置、フォントサイズなど）を文字列化して並べる実装が既に用意されているため、これを利用する。オプション項目例: *Colorblind Mode:* On/Off 切替、*Volume:* 0～100%、*Cast Key:* CやSpaceなどから選択、*Font Scale:* 1x,2x,...。各項目をリスト表示し、上下キーで選択移動、左右キーで設定値を変更できるようにする。例えば`colorblind`フラグはOnならOffに、OffならOnにトグル、`volume`は左右キーで増減、`cast_key`は左右で候補キーに変更、`font_scale`は1～数値を変更する。選択中項目はハイライトするなど視覚区別し、適用中の値もリアルタイムで反映させる（色覚モードOnならパレットを差し替え、フォント倍率変更は次回起動時適用かその場ではメッセージ表示する程度）。入力反映処理は`InputConfig`構造体に現在値を保持し、メニュー終了（Escもう一度押下など）時に設定を保存する（必要なら設定ファイル`lurhook.toml`に書き出す）。このオプションメニューにより、ユーザはゲームを再起動せずとも主要な設定を変更でき、快適なプレイ環境を整えられる。

* [x] **目的（改善の狙い）:** 高解像度環境でも文字が小さくなりすぎないようフォントサイズの拡大やウィンドウリサイズに対応する。
  **対象（設定・ビルド処理）:** フォント設定（`InputConfig.font_scale`、`BTermBuilder::with_tile_dimensions`の使用箇所）、ウィンドウイベント処理
  **内容:** **スケーラブルフォント**対応として、ゲーム起動時に設定されたフォント倍率で表示するようにする。具体的には`BTermBuilder::simple(80,25)`でコンソールを生成する際、`with_tile_dimensions(8 * font_scale, 8 * font_scale)`を呼び出してタイル1文字あたりのピクセルサイズを拡大する（font\_scale=2なら16×16ピクセルに）。`InputConfig.font_scale`によりユーザ指定の倍率を読み込み、デフォルトは1とする。併せて、ウィンドウのリサイズイベントにも対応させ、ウィンドウサイズ変更時には内部のコンソール表示を再作成または拡大縮小する。可能であれば`BTerm`が提供する`resize`メソッド等を利用し、動的に列数・行数を拡大して再描画する（本ライブラリで自動対応が難しければ、最低限起動時のサイズ変更オプションのみ提供）。この機能により、高DPIディスプレイでも文字が読みやすく表示でき、ユーザは自分の環境に合わせた表示スケールでプレイ可能となる。

* [x] **目的（改善の狙い）:** マウスによる直感的な操作を可能にし、キーボード操作に不慣れなユーザでも遊びやすくする。
  **対象（入力処理）:** マウス入力受付（例: `BTerm.left_click`座標）、タイトル画面UI（未実装なら実装する）
  **内容:** ゲーム操作の**マウス対応**をオプション機能として実装する。まずタイトル画面やメニューでのボタン選択にマウスクリックを使えるようにする（タイトルの「New Game」「Exit」等のボタンを描画し、`left_click`イベント時にその座標がボタン上なら該当の処理を実行）。またゲーム本編では、探索モード中にマップ上の任意の地点を左クリックすると自動でその方向に1マス移動する、あるいはその地点まで可能なら連続移動（経路探索が必要ならシンプルな実装を行う）する。また釣りキャスト時には、マップ上で左クリックした地点を即ターゲットに設定してキャスト確定できるようにする（`GameMode::Aiming`時にマウス位置`ctx.mouse_pos`を取得し、対応するゲーム内座標をtargetに反映）。実装の一例として、`handle_input`内で`if ctx.left_click { let (mx,my)=ctx.mouse_pos; ... }`の分岐を追加し、ゲームモードに応じて処理を変える。探索モードならクリック位置に隣接する方向へ`Player.pos`を動かす、エイミングモードならその位置をtargetにセットして即`confirm_cast()`を呼ぶなど。マウス操作はキーボード操作と併用可能にしつつ、オプション設定で有効/無効を切り替えられるようにすると尚良い（誤クリックでミスしないようにするため）。これらを実装することで、UIのボタン操作やマップ移動・釣り操作がマウスでも行えるようになり、ユーザビリティが向上する。

* [x] **目的（改善の狙い）:** 音によるフィードバックでゲーム体験を向上させ、イベントの臨場感を強化する。
  **対象（追加機能）:** オーディオ再生ライブラリ（例: `rodio`や`bevy_kira_audio`）、各イベント処理（ヒット時、糸切れ時など）
  **内容:** ゲーム内イベントに応じた**効果音とBGM**を追加する。効果音については、以下のタイミングで再生する音ファイルを用意し実装する: 魚がヒットした瞬間（リールに手応えが伝わった音）、ラインが切れた時（ブチッという断線音）、釣り成功時（ファンファーレや水しぶき音）、嵐発生時（風雨の環境音）など。それぞれ該当の処理箇所で音声再生関数を呼び出す。例えば`if bite { play_sound(\"hit.wav\") }`、`if state == Broken { play_sound(\"line_snap.wav\") }`のように実装する。音声再生には軽量ライブラリ`rodio`などを利用し、予め音声リソースを読み込んでおき再生のみ行う。また環境に応じた**BGM**も導入する。通常探索時は静かな海の雰囲気音楽、夜間はしっとりとした曲、嵐の最中は不穏なBGM、ボス魚とのファイト時には緊迫感のある曲、といった具合にシーンに合わせたループBGMを用意する。これらBGMトラックをゲーム状態（昼夜・嵐・戦闘）に応じてクロスフェード再生する仕組みを実装する。音量設定は前述のオプションメニューの値を参照し、効果音・BGMとも再生音量に反映させる。音声再生により、視覚情報だけでなく聴覚的にもイベントが伝わり、ゲームへの没入感が向上する。

* [x] **目的（改善の狙い）:** ゲームの進行に応じて新たなエリアを解放し、探索範囲と難易度の段階的な上昇によってリプレイ性を高める。
  **対象（構造体・関数）:** エリア管理（`game-core::types::Area`列挙型とサイズ/hazard倍率）、エリア進行判定（`LurhookGame.check_area_upgrade`）
  **内容:** マップを**沿岸→沖合→深海**の3段階エリアに分け、一定条件で次のエリアがアンロックされる仕組みを実装する。`Area`列挙型でCoast/Offshore/DeepSeaを定義し、それぞれに対応するマップサイズ（例: Coast=80x50, Offshore=120x80, DeepSea=160x120）と危険度補正（hazard\_multiplier: Coast=1, Offshore=2, DeepSea=3）を設定する。ゲーム開始時は`area = Coast`でスタートし、プレイヤーが一定の成果を達成するごとに`area`を次段階に更新する。具体的な条件は**図鑑に登録された魚の種類数**や**累計捕獲数**とし、例えば累計3匹釣り上げたら沖合解禁、6匹で深海解禁とする。判定は魚捕獲成功時に`Codex.total_captures()`を参照して行い（`check_area_upgrade`関数）、条件を満たした場合は現在の`area`を次の段階に変更する。エリアが変わったら、新たなマップを生成し直して切り替える。具体的には`self.area.size()`に基づき新マップを`generate`し、`self.map`や`self.fishes`を作り直す（異なるシード値で再生成することでマップが一新される）。プレイヤー位置も新マップの中央など安全な初期位置にリセットする。さらにログに「Unlocked offshore area!（沖合エリアが解放された！）」等のメッセージを表示してプレイヤーに通知する。新エリアではマップが広がり探索範囲が増える一方、hazard\_multiplier上昇により危険イベント発生率も上がるため緊張感も増す。これを段階的に行うことで、プレイヤーは徐々に遠出できるようになり、ゲーム後半でも新たな環境での挑戦が生まれる。

* [x] **目的（改善の狙い）:** 捕獲した魚の情報を記録・蓄積し、コレクション要素や実績システムと連動させてゲームの目標を明確化する。
  **対象（構造体・データ）:** 図鑑システム（`codex::Codex`構造体、保存ファイル`codex.json`）、実績データ（外部サービス連携箇所、またはスタブ）
  **内容:** \*\*図鑑（Codex）\*\*機能を実装する。`Codex`構造体では魚ID（種別）ごとに捕獲数を記録するハッシュマップを保持しており、ロード/セーブ機能も備わっている。魚を釣り上げた際（釣り成功時）に、該当魚IDのカウントを`record_capture`でインクリメントし永続化する処理を追加する。既に`check_area_upgrade`内で`Codex.total_captures()`を参照しているように、図鑑データはエリア解放の判定などゲーム進行にも利用できる。また、図鑑データはゲーム終了後や別画面で閲覧できるようにすると良いが、現時点では内部的な保存のみでも良い。加えて、Steam実績等と連動させる準備として、特定の達成条件を検出したら外部実績をアンロックする処理を将来的に入れられるようにする。例えば「全種類の魚を捕獲」「レア魚を捕獲」などの条件を設定し、図鑑内で達成フラグを立てておく（実装上はJSONにフラグを書き出す程度でも可）。現段階では外部API連携はしないが、記録が残ることでプレイヤーの収集欲を刺激し、長期的な目標が提供される。

* [x] **目的（改善の狙い）:** プレイヤーに難易度選択肢を提供し、初心者から上級者までそれぞれに合った挑戦ができるようにする。また各種パラメータを調整してゲーム全体のバランスを整える。
  **対象（構造体・パラメータ）:** 難易度設定（`game-core::Difficulty`列挙型と関連関数）、各種定数（`MAX_HUNGER`, `HAZARD_CHANCE`, 魚のパラメータ など）
  **内容:** Easy/Normal/Hardの**難易度モード**を導入し、難易度に応じてゲーム内のパラメータスケーリングを行う。例えばEasyでは満腹度減少を2ターンに1に緩和し（実装: `if turn % 2 == 0 { hunger_loss = 1 } else { 0 }`）、ハザード発生率や敵出現率を半減する。逆にHardでは満腹度減少を倍速にし（1ターンで2減少）、ハザード確率も2倍にする。これらは`Difficulty`列挙型にメソッドとして実装済み（`hunger_loss()`や`hazard_chance()`）なので、ゲーム開始時の選択によって`game.difficulty`を設定し、それを各所で参照してパラメータ計算するようにする。難易度選択UIはタイトル画面で矢印キーで選ぶか、オプションで変更できるようにする。デフォルトはNormalとし、選択結果を`LurhookGame::new_with_difficulty`経由でゲームに反映する。また、全ての機能実装後に**ゲームバランスの調整**を行う。各定数（満腹度減少量、各食料の回復量、魚の強さ、ハザード確率、エリア解放条件など）をプレイテストのフィードバックに基づき微調整する。例えば「難易度Normalでも満腹度減少が早すぎて序盤きつい」場合は減少を遅くする、「Hardでハザード頻発しすぎる」なら確率を下げる、逆に「Easyが簡単すぎる」ならもう少しペナルティを付ける、など。難易度ごとの目標体験を明確にしつつ、全体として理不尽さや退屈さが無いよう数値を調整し、最終的なゲームバランスを整える。

* [x] **目的（改善の狙い）:** ゲームをブラウザ上でも体験できるようにし、より多くのユーザにプレイしてもらう。
  **対象（ビルド設定）:** WebAssemblyビルド（`wasm-pack`用設定、`Cargo.toml`の`wasm-bindgen`関連）、デプロイスクリプト（GitHub Pages等）
  **内容:** **WASMビルド**対応を行い、ゲームをWebブラウザで動作させる。まず`wasm-bindgen`や`bracket-lib`のWebGPUバックエンドに合わせてコンパイルできるよう、Cargoのターゲット指定（例: `wasm32-unknown-unknown`）でビルドするための設定を整える。`wasm-pack build --target web`コマンドでビルドし、生成された`pkg`をGitHub Pagesなどでホスティングする。ファイル読み込み（JSONアセットやセーブデータ）部分はWASMではファイルシステムに直接アクセスできないため、`include_str!`で埋め込むか、ブラウザのローカルストレージAPIに置き換えるなどの対応を行う（現状テスト用に`load_fish_types_embedded`等で埋め込み関数が用意されている）。ビルド後、GitHub Pagesに配置するため、リポジトリのGitHub Actionsや手動で`docs/`ディレクトリに`index.html`と`pkg/`を置いて公開する。これにより、利用者はインストール不要でブラウザからゲームを試遊できるデモページにアクセスでき、フィードバック収集や認知度向上に繋がる。

* [x] **目的（改善の狙い）:** 実装内容を開発文書に反映し、将来的な開発者や協力者がシステム設計を理解しやすいようにする。またプレイヤー向け情報も最新化する。
  **対象（ドキュメント）:** 設計書（`docs/designs.md`）、README（`README.md`）
  **内容:** 開発完了後に**ドキュメント更新**を行う。まず設計書`designs.md`に、本実装で追加された仕様を追記/修正する。具体的には満腹度システム（最大値100・ターン経過減少・空腹時のHP減少など）や新規導入したアイテムカテゴリ（ロッド/リール/ルアー/食料）、魚AI拡張（潮流・群れ行動・レア魚）や新UIフロー（キャストエイム操作、オプションメニュー、ヘルプ画面）について章を設けて記述する。またコード構成が大きく変わった場合はファイル構成や依存関係図も更新する。加えて、プロジェクトのREADME.mdも最新内容に合わせて更新する。ゲームの遊び方（操作方法はヘルプ画面参照を促しつつ主要キーを記載）、ビルド手順（WASMビルド方法や必要ツールなど追記）、開発ロードマップ（今回実装した改善項目のチェックリストを進捗として載せる）を反映する。このようにドキュメントを整備することで、開発者・ユーザ双方にとってプロジェクトの全貌が分かりやすくなり、今後の保守・拡張もスムーズに行える。
