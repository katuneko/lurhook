# Lurhook Game Improvement TODO Checklist

## Core Game System

* [x] **Random Map Generation:** Implemented map creation using BSP and Perlin noise to generate a grid of tiles with land (`.`), shallow water (`~`), and deep water (`≈`) regions. This provides a new 80×25 map each run with depth variations for fishing spots.
* [x] **Player Movement & Boundaries:** Enabled 8-directional player movement (including diagonals) with keyboard input (h/j/k/l or arrow keys, etc.), clamping the “@” player position within map bounds. The player can freely explore the map without moving off-screen.
* [x] **Turn-Based Game Loop:** Integrated the main game loop using the bracket-lib engine. Each tick processes player input and then updates game state (e.g. moves fish) before rendering the map. This ensures a deterministic turn order where exploration mode calls fish AI updates and fishing mode runs the fishing mini-game logic.
* [x] **Return & Scoring System:** Add a mechanism to **end the fishing run** – for example, letting the player return to the start or press a key to conclude the trip – and then calculate a **final score** based on the fish caught. This involves defining a win/lose condition (e.g. voluntary return or “dropout” if HP or equipment is depleted) and tallying points (using fish rarity/values) to display the results.
* [x] **Day-Night Cycle:** Added a simple turn-based clock. Each tick advances a counter and updates the `time_of_day` string through Dawn → Day → Dusk → Night in a loop.

## Fishing Mechanics

* [x] **Casting & Mode Switch:** Pressing the cast key (`c`) throws the line and switches the game state into **Fishing mode**. The UI layout changes and the game enters a waiting period (e.g. 2 turns) to simulate the line sinking before bite checks begin.
* [x] **Bite Event Trigger:** After casting and a short wait, the game determines if a fish bites. Currently this uses a fixed probability (50% chance) to trigger a “Hooked a fish!” event. On a bite, the hooked fish is selected for the mini-game; otherwise, a log message indicates the fish got away and the game reverts to exploration mode.
* [x] **Tension Bar Mini-Game:** When a fish is hooked, a **tension meter** is displayed and the player must press the reel key (`r`) strategically to keep tension below the breaking point until the timer expires. Each turn, not reeling causes tension to rise by the fish’s strength, while reeling reduces tension. If tension exceeds the max (line snaps) or the duration elapses, the mini-game ends with failure or success respectively.
* [x] **Catch Outcome & Inventory:** Implemented outcome handling for the fishing mini-game. On success, the fish is pulled in – it’s removed from the map and added to the player’s inventory (of caught fish). On failure (the line broke or the fish escaped), the fish remains in the water (not caught) and the game returns to exploration.
* [x] **Adaptive Bite Probability:** Improve the bite chance calculation to use environmental and gear factors instead of a flat rate. For example, incorporate the water depth and bait/lure type into the formula for fish biting. This would fulfill the design goal that deeper waters and certain baits affect how likely a fish is to bite, adding strategic depth to casting choices.
* [x] **Line Durability Mechanic:** Introduce consequences for line breaks to make the resource meaningful. Each time the line snaps during the tension mini-game, reduce the player’s `line` durability stat (e.g. subtract from the 100 line strength). If the line durability falls to zero, the player can no longer fish (forcing a **dropout**). This ensures that repeated failures have a cost and encourages careful reeling.

## Ecosystem & AI

* [x] **Fish Spawning on Map:** On world generation, populate the map with fish entities at valid water tiles. Currently, one fish is spawned at a random water tile on startup. This establishes an initial ecosystem by placing fish in shallow or deep water areas where they can be encountered by the player.
* [x] **Basic Fish Movement AI:** Implemented a simple AI for fish behavior. Each turn during exploration, fish perform a random walk – moving by a small random delta – and are constrained to stay within water tiles (shallow or deep). This gives the world a dynamic element as fish wander around rather than staying static.
* [x] **Multiple & Rare Fish Population:** Expanded the spawning system to create several fish using rarity-weighted species selection. The game now spawns five fish at startup so players can encounter common and rare species in a single run.
* [x] **Depth-Specific Spawning:** Map generation now assigns numeric depths to water tiles (0–100m) and spawning filters by each fish type's depth range.
* [ ] **Schooling Behavior:** Implement a group AI so that some fish form **schools**. Rather than moving completely independently, fish of the same school could follow a leader or move in a loosely cohesive cluster with some noise. This would make the ocean feel more alive – for instance, smaller fish might travel in groups, making them easier or harder to catch en masse and adding another layer to fish behavior.
* [ ] **Time-of-Day Activity:** Tie fish behavior and spawning to the day-night cycle. Certain fish could become more active or move differently during specific times (e.g. nocturnal fish emerge at Night, others hide at Dusk). This will use the implemented time cycle to vary the ecology: for example, at Night fish might move faster or spawn in different areas, encouraging the player to consider time when planning to catch specific fish.
* [ ] **Tidal Currents Effect:** Simulate ocean currents that influence fish movement patterns. For instance, implement a subtle drift where, during certain periods (tides), all fish positions shift or bias in one direction (and perhaps back again with ebb/flow). This environmental effect would add realism and challenge – the player might find fish have moved with the current, making positioning and timing more important.

## UI/UX Improvements

* [x] **ASCII Map & Entity Rendering:** The game renders the map and entities in a clear ASCII format. Land tiles are shown as `.` and water as `~` (shallow) or `≈` (deep), with the player represented by `@` and fish by `f` on the map. This is implemented and provides an at-a-glance view of terrain and creatures each turn.
* [x] **Fishing Mode Layout Toggle:** When the player enters fishing mode, the UI switches from the standard exploration layout to a fishing layout. In this mode, the **tension bar** is shown (at the bottom of the screen) and non-essential HUD elements adjust, focusing the interface on the fishing mini-game. On returning to exploration, the layout reverts to the normal view.
* [x] **Event Log Panel with Scrolling:** A scrollable log panel displays recent game events (e.g. movement results, bite messages, outcomes). The log retains about 8 lines of text on screen, and the player can scroll up or down with PageUp/PageDown to review past messages. This feature is implemented, enhancing transparency of game events.
* [x] **Status Panel Stats:** A status panel is shown, listing player vitals and context: **HP**, **Line** durability, current **Depth**, and **Time of day**. These values update in real-time (except depth/time are placeholders for now) to give the player feedback on health and equipment, as well as environment depth and day/night status.
* [x] **Inventory Display:** Implement an inventory view accessible via the `i` key, allowing the player to see what fish they have caught so far. This could be a simple text list or panel showing each captured fish’s name (and perhaps value/weight). Providing an inventory UI confirms successful catches and helps players plan (e.g. decide if they have room or need to return).
* [x] **Key Rebinding Support:** Allow players to remap controls for personal comfort and accessibility. For instance, read a configuration file (e.g. `lurhook.toml`) on startup to override default key bindings. This task involves defining a configurable input mapping and adjusting the input handling code to use it, so that players (especially on non-QWERTY keyboards or with preferences) can customize controls.
* [ ] **Colorblind-Friendly Palette:** Provide alternate color schemes or symbols to accommodate colorblind players. The game should ensure important elements (land vs water, fish vs background, tension levels, etc.) are distinguishable without reliance on color hues. This may involve adding a toggle or automatically switching to a high-contrast palette and testing the ASCII colors for common color vision deficiencies.
* [ ] **Visibility & LOS Effects:** Implement limited visibility rules, especially for deep water tiles. For example, in deep water areas the player’s field of view could be restricted, mimicking the darkness of the ocean depths – tiles and fish beyond a certain radius would not be visible unless illuminated or approached. This adds atmosphere and challenge, as venturing into deep sea would require careful exploration.
* [ ] **Menu and End-of-Run Screens:** Add a title screen (main menu) and an end-of-run summary screen to frame the gameplay experience. On launch, a simple menu can prompt to Start Game (and possibly Load Game or view Instructions), aligning with the requirement of a title sequence. After the player returns or loses (end of expedition), display a summary showing total score and maybe stats like number of fish caught, then offer options to play again or quit.

## Peripheral Features

* [x] **Data-Driven Game Content:** External JSON data is integrated for easy content management – e.g. fish species stats are loaded from `assets/fish.json` at startup. This is implemented, allowing fish properties (name, strength, rarity, depth range) to be modified without code changes. It sets the stage for flexible expansion of game content and balancing.
* [ ] **Item Types & Gear Effects:** Utilize `assets/items.json` (which defines fishing rods, lures, bait types, etc.) to introduce gear mechanics. The player could select or find different rods and baits that influence gameplay – for example, a stronger rod increases max tension, or special bait increases bite rate for certain fish. Implementing this involves loading the item data and modifying fishing mechanics to account for equipped gear (e.g. adjusting bite probability or tension meter based on items).
* [x] **Save & Load System:** Implemented the ability to save the game state to a file and load it back later. The game serializes key state (e.g. player position, HP, time of day, etc.) to a RON-formatted save file and can parse this file to restore a game session. This persistence feature is complete, enabling players to continue their adventure across sessions.
* [x] **In-Game Save/Exit Options:** Expose the save/load functionality and a proper exit through the UI. For example, allow pressing `S` in-game to quickly save progress, and `Q` to quit the game safely. This task involves adding input handling for those keys and possibly a confirmation prompt or menu selection for saving/quitting. It ensures players can pause and resume play at will, and exit without losing progress.
* [ ] **Web (WASM) Deployment:** Prepare the game for WebAssembly deployment, allowing it to run in browsers. This requires building the project with the `wasm-pack` target and possibly adjusting some systems (e.g. file access or random number seeding) for a web environment. Once ready, publish the WASM build (for instance on GitHub Pages) so that players can play **Lurhook** on the web without installation. This expands the game’s reach and is planned as part of the final release.
