ありがとうございます。`docs/requirements.md` と `docs/designs.md` の内容、そして `katuneko/lurhook` のコードベースに基づいて、ローカル環境を前提とした開発を段階的に進めるためのステップバイステップのタスクを設計します。品質を結合ポイントで段階的に固めるアプローチで、テストやCIもシンプルかつ技術的に筋の良い方法を提案します。

完了次第、詳細なタスクリストと開発計画をご報告します。


# Lurhook開発: 結合ポイント重視のステップバイステップ計画

まず、**Lurhook**の要件定義と外部設計に基づき、モジュール間の結合ポイントに注目した開発計画を策定します。一度に全機能を実装するのではなく、**段階的に統合し品質を高める**アプローチを取ります。要件書には開発フェーズが示されており、フェーズ0～5で順に「ビルド通過」「プレイヤー移動（空マップ）」「マップ生成」「釣りメカニクス」「魚AI・深度」「仕上げ」と進む予定です。これを踏まえ、以下のステップごとにタスクと計画を整理します。

## ステップ1: 開発環境セットアップとCI基盤の構築

* **環境準備:** Rustツールチェインをセットアップし（Rust stable 1.78+）、リポジトリをクローン後に`cargo run`でビルド・実行します。現状では `"Welcome to Lurhook! (engine stub)"` と表示されれば環境構築成功です。
* **CI初期導入:** 早期に簡易なCIパイプラインを導入し、プッシュ時に自動でビルドとテストが走るようにします。GitHub Actionsを用い、まずは`cargo clippy`によるLintと`cargo test`の実行を設定しましょう（最初はUbuntu単一環境で十分です）。以降の開発でCIを徐々に拡張し、将来的にはマトリクスビルド（Windows/Linux/macOS）やWASMビルド・テストも組み込む計画です。

## ステップ2: 結合ポイントの洗い出しとモジュール間インターフェース設計

* **アーキテクチャ確認:** 現在のCargoワークスペースには、実行可能クレート（`lurhook`）と5つのライブラリクレート（`game-core`, `mapgen`, `ecology`, `fishing`, `ui`, **+** `data`）が存在します。設計図ではExecutableが`game-core`を通じて各モジュール（ui, fishing, ecology, mapgen）を利用する構成です。まずはこの**結合ポイント**を洗い出します。具体的には以下が主要ポイントです:

  * `game-core` ↔ `mapgen`: マップ生成の呼び出しと結果受け渡し（例: `Mapgen::generate(seed) -> Map`）。
  * `game-core` ↔ `ecology`: 魚エンティティ配置処理（例: `Ecology::spawn_fish(map)`）。
  * `game-core` ↔ `ui`: ゲーム状態の描画更新とログ通知（UIコンテキスト経由）。
  * `fishing` ↔ `ui`: 釣りテンションバー表示制御（`TensionMeter`構造体経由）。
  * `data` ↔ 他モジュール: 外部データ（魚種リストJSONやセーブファイル）読み書き。
  * その他、外部ライブラリとの接続（例: **bracket-lib**によるゲームループ&描画、**hecs**によるエンティティ管理など）。

* **インターフェース設計とスタブ実装:** 上記の結合箇所について、まずは**モジュール間のインターフェース**を定義します。各クレートにおいて、設計書のインターフェース表に沿った関数や構造体のプロトタイプを用意しましょう。具体的には:

  * `mapgen`クレートに`pub fn generate(seed: u64) -> Map`関数を追加（現段階では固定の簡易Mapを返すスタブ実装）。
  * `ecology`クレートに`pub fn spawn_fish(map: &mut Map)`関数を追加（現段階ではダミーで魚を1匹配置するか、`println!`で呼び出し確認する程度）。
  * `fishing`クレートに**テンションメーター**用の`pub struct TensionMeter`を定義し、`pub fn update(&mut self)`や描画用のメソッド（スタブ）を用意。まずは内部に釣り糸のテンション値など状態を保持する構造だけ定義。
  * `ui`クレートにゲーム側から操作する**UIコンテキスト**（例: `pub struct UIContext`）を定義し、ログ追加`add_log(msg: &str)`や画面リフレッシュ`refresh()`などのメソッドをスタブ実装。
  * 必要に応じて**共通型**を設計: 例えばエラー型`GameError`を`game-core`か共有モジュールで定義し、全クレートで`Result<T, GameError>`を扱えるようにします。またゲーム内で使う基本的な構造体（座標型`Point`やタイル・魚・プレイヤーの構造体など）もこの段階で定義だけしておくと、今後の実装がぶれません。

* **スタブ同士の結合:** インターフェースを用意できたら、各スタブ関数を\*\*`game-core::run()`から呼び出してみます\*\*。現在`game-core::run()`は簡易な挨拶を表示するだけなので、これを拡張し、`mapgen::generate`でマップ生成→`ecology::spawn_fish`で魚配置→`ui::init`でUI初期化…といった順に関数呼び出しを追加してみます（処理の中身は現時点ではログ出力程度）。この流れを`cargo run`で実行し、**全モジュールが正しくリンクして呼ばれる**ことを確認しましょう。例えばコンソール出力で「Initialized crate: mapgen」「Initialized crate: ecology」... 等が順に表示されれば、モジュール間の結合は一通り成功しています。
  （※将来的にこの初期化処理はゲーム開始処理に発展させますが、この段階では結合テストが目的です。）

## ステップ3: 基本的なUIループの構築（ブラケットライブラリ統合）

* **描画環境の構築:** 次に、**ブラケットライブラリ（bracket-lib）**を用いてゲームの描画ループを実装します。Lurhookはデフォルトではデスクトップ向け（OpenGLバックエンド）をターゲットとしています。`game-core`または`ui`モジュール内にブラケットの`GameState`トレイトを実装した**状態管理構造体**（例: `struct LurhookGame { ... }`）を作成しましょう。この構造体にマップやプレイヤー等ゲーム状態を持たせ、`fn tick(&mut self, ctx: BTerm)`で毎フレームの更新・描画処理を記述します。
* **メインループ統合:** `main.rs`からは`game_core::run()`経由で、ブラケット-libの`BTermBuilder`等を使いウィンドウを初期化し、`main_loop(context, gameState)`を呼び出すように実装します。まずは**シンプルな画面**を表示することが目標です。例えば背景を黒、デフォルト色で「@」(プレイヤー)を中央に一つ描画するか、タイトル文字列を表示する程度でも構いません。これにより**UIモジュールとゲームループの結合**を確認します。
* **UI初期化処理:** `ui::init()`に相当する処理で、画面サイズ（80×25ターミナル相当）やフォント設定などを行います。ブラケット-libではコンソールを80x25サイズで用意し、フォントはASCII文字を使います。設計書のUIレイアウトに従い、この段階では大雑把に**1つのコンソール領域**に全画面を描画する想定で十分です（ログやステータス分割は後で実装）。
* **確認:** このステップ完了時点で、`cargo run`するとウィンドウが開き、指定したとおりの文字やシンボルが描画され続けるはずです。キー入力受付はまだ実装しませんが、ウィンドウを閉じると正常終了するか確認しましょう。

## ステップ4: プレイヤー移動と入力ハンドリングの統合

* **入力→ゲーム状態反映:** 次は**プレイヤーの移動操作**を実現します。設計上、h/j/k/lキーまたは矢印キーで8方向に1タイル移動できる仕様です。ブラケット-libの`BTerm`経由でキー入力イベントを取得し、プレイヤーの座標を更新する処理を実装しましょう。`LurhookGame`構造体にプレイヤー位置（例: `player_pos: Point`）を保持し、`tick()`内で`ctx.key`をチェックして該当キーが押されたら座標を変更します。
* **マップと当たり判定:** 現在は仮の**空マップ**を表示している状態なので、移動は自由にできます。床以外の地形（例えば水中や障害物）が出てくるのは後続ステップのマップ生成以降ですので、この時点では境界チェック程度で十分です。画面端に行こうとしたらそれ以上進めない処理を入れておきましょう。キャラクター「@」は`tick()`内で毎フレーム描画していますが、位置更新後に再描画することで移動が画面に反映されます。
* **ゲームループ統合:** これで**基本ループ**として「入力→状態更新→描画」のサイクルが確立しました。今後他のシステム（AIや釣り等）を組み込む際も、このサイクルの中で処理を差し込んでいきます。現時点で\*\*フェーズ1（移動可能なプレイヤー & 空マップ）\*\*の目標が達成されました。動作確認として、プレイヤーが画面内を移動できること、画面外にはみ出さないことをテストしましょう。

## ステップ5: マップ生成（Mapgen）機能の実装と統合

* **スタブから本実装へ:** 空の固定マップから脱却し、**ランダムマップ生成**を行います。`mapgen::generate(seed)`関数にアルゴリズムを実装しましょう。要件定義によると「BSP＋パーリンノイズで海域/島をランダム生成し、各タイルに浅瀬/深海フラグを付与する」とあります。まずはBSP（区画分割）で地形（陸地と水域）を大まかに作り、パーリンノイズで変化をつけて滑らかにし、各セルに属性を持たせる実装方針です。
* **データ構造設計:** マップを表す`Map`構造体（2次元グリッド想定）を定義し、タイルタイプ（陸地・浅瀬・深海など）を列挙型で持たせます。加えて深度（深海レベル）や地形フラグをタイルに保持させましょう。`generate(seed)`では乱数シードを受け取り、同じシードなら同じマップを生成できる**再現性**も持たせます。
* **統合と描画:** 生成した`Map`は`game-core`で保持し、ゲーム開始時に一度呼び出して作成します。生成直後に`ui`モジュールを通じてマップを描画できるようにしましょう。具体的には、`tick()`内の描画処理でマップ内の各座標についてタイルに応じた文字（例: `.`=浅瀬、水面, `~`=深海, `#`=陸地 など）を出力します。設計書のUI例ではマップ領域に波線やドットで表現しています。プレイヤー「@」はマップ上の位置に重ねて描画します。
* **テストと検証:** ランダム生成が正しく行われているか、いくつかシード値を変えて目視確認します。特に**浅瀬と深海のフラグ付け**が所望通りか確認しましょう（例: 陸地の周囲数マスは浅瀬、それ以降は深海など、要件に即した深度分布になっているか）。また、**ゴールデンマスターテスト**の導入を検討します。これは特定のシードで生成したマップをファイルに保存し、将来的な変更で同じシードからの生成結果が変わった場合に検知する手法です。変更の影響を把握しやすくするため、`cargo test`で特定シードの出力をスナップショットとして比較するテストを作成すると良いでしょう。

## ステップ6: 魚の配置とエコロジーモジュールの統合

* **魚エンティティ導入:** 次に**エコロジー（生態系）**の要素として魚をマップ上に登場させます。`ecology::spawn_fish(map)`関数を本実装に置き換え、生成済みマップ上に魚の出現位置を決定しましょう。初期段階ではシンプルに、マップ内の特定の水域タイルに1匹の魚を配置する程度で構いません。魚を表す構造体（例: `Fish { position: Point, species: FishType, ... }`）を定義し、ゲーム状態で管理します。魚の**表示**には適当なASCIIシンボルを使います（例: `)`: 魚を右向きの曲線で表現）。
* **深度と種別:** 将来的には魚種は浅瀬/深海など出現条件やレア度がありますが、まずは固定種別または乱数で種別決定し、1種類だけ使います。配置場所も現時点ではマップ中央付近の水タイルなどに置き、動的出現は後で導入します。
* **統合:** `game-core`のゲーム開始時に`mapgen::generate`の後で`ecology::spawn_fish`を呼び出し、ゲーム内の**魚リスト**に魚オブジェクトを登録します。描画処理ではその位置に魚シンボルを描画するようにUI側を修正しましょう。これでプレイヤーから見てマップ上に魚が存在する状態になります。
* **確認:** プレイヤーを魚のいる座標まで移動させ、魚シンボルと重なれること（現時点では何も起こりません）を確認します。魚はまだ動かない想定ですが、それでも**モジュール結合ポイント**としてマップと生態系の連携が実現できています。今後の釣り処理や魚AI実装に向け、魚リスト管理や描画処理が正常に機能していることをテストしましょう。

## ステップ7: ターン処理と魚の簡易AI（エコロジー拡張）

* **ターン制ループへのAI組み込み:** 設計書にあるターン処理フローにならい、1ターンごとに**魚の行動AI**を更新します。まずは簡易的な実装として、一定確率で魚がランダムな隣接水タイルへ移動する挙動を追加しましょう。`ecology`に`pub fn update_fish(map, fish_list)`のような関数を用意し、ゲームループ内（各フレームまたはプレイヤー行動の後）で呼び出します。これにより**プレイヤー入力→魚AI更新→描画**という流れが実現します。
* **AIロジック:** 要件では「魚は昼夜・潮流で行動パターン変化」「群れAI（リーダー追従＋ノイズ）」等が挙げられています。これらは高度な内容なので、まずは**単純なランダム遊泳**で十分です。例えば毎ターン8方向のいずれか（または静止）をランダム選択し、次の位置が水タイルなら移動する、といった実装です。複数の魚がいる場合はループで全魚に対して適用します。
* **時間経過要素:** 将来的拡張のために、ゲーム内で時間（昼/夜）を管理し、魚AIに影響を及ぼす仕組みも検討しますが、この段階では時間は固定（例: 常に昼）で構いません。
* **統合テスト:** プレイヤー非操作時にも毎ターン魚が動いているか観察します。魚が陸地に上がってしまわないか（境界チェック）、重なった複数魚が同じタイルに留まらないか等を確認しましょう。問題があれば`update_fish`内で適切に位置妥当性チェックを行います。ここまでで\*\*フェーズ4（魚AI & 深度）\*\*の基本部分である「魚の移動」が実装され始めました（深度による種別違いは後述）。

## ステップ8: 釣りモードの実装とゲームコアへの統合

* **釣りモードへの遷移:** いよいよ**釣りメカニクス**に取り掛かります。プレイヤーの入力コマンドで`c`キー（キャスト）を押すと釣りモードに入るよう実装します。ゲームループ内で`c`キーを検知したら**照準モード**へ遷移し、プレイヤーに釣り糸を投げ入れる方向と飛距離を選択させます（G-FISH-01 要件）。初期実装としては、プレイヤーの向いている方向に固定距離でキャストする、など簡略化しても構いません。
* **バイト（魚のヒット）判定:** キャスト後、一定ターンの**待機**を経て魚が食いつく（バイト）イベントを発生させます。G-FISH-02の要件では「深度・餌によってバイト確率を計算する」とあります。まずはシンプルに、一定確率（例えば50%程度）でバイトが発生するようにしましょう。魚が実際に存在する場合は近くにいる魚種に応じて確率変動させることも考えられますが、段階的開発の観点から**ダミーの確率計算**（深度や餌は考慮せず固定確率）で実装し、後で拡張します。
* **ヒット時の処理:** バイトが発生したら、ゲームを**釣りミニゲーム状態**へ進めます。この段階ではテンションバーを用いた本格的な処理は次ステップに譲り、まずは**即時成功/失敗の判定**を入れて流れを通します。例えば「バイト発生→即魚捕獲成功」として魚を捕獲したことにし、プレイヤーのインベントリ（持ち物リスト）にその魚を追加します。もしくは一定確率で失敗（魚が逃げる）とし、その場合は何も得られない結果にします。
* **ゲーム状態復帰:** 釣り処理が完了したら通常の探索モードに戻します。キャスト位置から釣果を得た場合、魚エンティティはマップから削除する（捕まえた魚は消える）処理も必要です。これにより、**探索ループ→釣り→探索復帰**という一連の流れが実現します。
* **検証:** 釣りコマンドを実行し、成功時にはインベントリに魚が増える、失敗時には特に変化がないことを確認します。統合ポイントとして、`game-core`から`fishing`モジュール（釣りロジック）を呼び出し、結果次第でUI（ログ表示やインベントリ表示）に反映させる部分を点検しましょう。ログには「魚がかかった！」「逃げられた…」などメッセージを追加すると臨場感が出ます（このログ表示機能は次ステップで強化予定です）。

## ステップ9: テンションバーによる釣りミニゲームの完成

* **テンションバー実装:** 簡易版釣りフローができたら、要件の肝である**テンションバーでの強度管理**を実装します（G-FISH-03）。前ステップで導入した`fishing::TensionMeter`構造体の出番です。この構造体に釣り糸の張力値や耐久限界値、魚の抵抗力などのプロパティを持たせ、**リアルタイムに変動するゲージ**として扱います。例えば`TensionMeter { tension: 0, max_tension: 100, fish_strength: N, ... }`とし、魚が引くたびに`tension`が`fish_strength`に応じて増加するような仕組みです（fish.jsonに定義された`strength`が閾値増加係数となる）。
* **インタラクティブなゲーム性:** テンションバーが上昇し過ぎて閾値を超えると釣り糸が切れて失敗となります。プレイヤーはそれを防ぐために何らかの操作を行えるようにします。例えば一定間隔でバーが増減する中、プレイヤーがタイミングよくキーを押すと一時的に緩められる、といったミニゲームを設計します（具体的操作方法は設計自由ですが、シンプルに**連打でテンション減少**などでも良いでしょう）。ブラケット-libではフレームごとに入力を検知できるので、テンションゲーム中は通常のターン制から**リアルタイムまたは擬似リアルタイム処理**に切り替える形になります。
* **UI表示:** `ui`クレート側でテンションバーを画面に描画します。設計上、テンションバーは釣り中のみマップ下部に表示するとのことです。実装としては、釣りモードに入ったらUIレイアウトを一時的に切り替え、画面下行に現在のテンション量をバー（たとえば「▓▓▓░░」のようなゲージ表示）で描画します。またログやステータスパネルは釣り中も更新されるので、全体の描画レイアウト管理に注意します。
* **成功/失敗判定:** プレイヤーが適切にテンションを管理できれば一定時間で魚を弱らせてキャッチ成功、失敗すれば糸が切れて魚逃亡という結果にします。成功時はインベントリに魚追加、失敗時はプレイヤーのライフや装備耐久を減らす処理も考えられます（要件では糸切れ＝失敗なのでライフ減は不要かもしれませんが、ペナルティがあるとゲーム性が増します）。
* **テスト:** テンションバーの挙動はランダム要素も絡むため、自動テストは難しい部分ですが、ロジック自体はユニットテスト可能です。例えば`TensionMeter`に対して魚の引き強度計算や閾値判定ロジックが正しく動作するかテストを書きます。閾値ぎりぎりで止まるケースやオーバーシュートするケースなどを想定しましょう。ここでの狙いは、**釣りシーケンス全体が安定して動作すること**です。手動テストとして何度か釣りを試し、成功・失敗両パターンが適切に発生するか確認します。

## ステップ10: UIパネルとログ機能の充実

* **ログウィンドウ実装:** これまで随所でイベントログを表示するようコメントしてきましたが、本格的に**ログパネル**を実装します。設計では画面下部左に最大8行のログウィンドウを配置し、PgUp/PgDnでスクロール可能とのことです。UIクレートの`UIContext`に`add_log(msg: &str)`メソッドを実装し、内部でログメッセージのキュー（Vec<String>など）を管理します。`tick()`ごとに最新ログ数行を描画領域に描くことでログ表示を更新します。ゲーム内の重要イベント（マップ生成完了、魚スポーン、キャスト開始、バイト発生、捕獲成功/失敗など）でこの`add_log`を呼び出し、ユーザーに情報を伝えます。
* **ステータスパネル実装:** 画面下部右側にはステータスパネルがあり、HPや釣り糸の耐久、現在の深度や時刻を表示します。これもUI側で描画し、ゲーム状態から数値を取得します。例えば`player.hp`、`player.line_strength`、`game.depth`（プレイヤーの現在位置の水深）、`game.time_of_day`などを表示します。HPやLine（釣り糸耐久）はハートやゲージで表現し、時刻はDawn/Day/Dusk/Night等の文字列で表示するとよいでしょう。
* **UIレイアウト管理:** ログとステータスパネル、およびテンションバーの表示/非表示を含め、UI全体のレイアウトを仕上げます。通常探索時はログ＋ステータスを表示、釣りモード時はそれらに加えてテンションバーを表示（あるいはテンションバーをログ領域に重ねて表示）するレイアウト調整を行います。ブラケット-libではコンソール分割や複数コンソールを使う方法もありますが、まずは単一画面に描画座標を決め打ちして配置しても構いません。
* **検証:** プレイヤーの行動や釣り結果によってログメッセージが逐次現れ、想定どおり8行分まで表示・スクロールされること、ステータスが状況に応じて変化することを確認します。例えば魚を捕まえたらログに「○○を釣り上げた！」、ステータスのInventoryやスコアが増える、といった目視確認を行います。

## ステップ11: データ読み込み・セーブ機能の導入（Persistence）

* **外部データの活用:** `assets/`ディレクトリに用意されたJSONファイル等をゲーム内で読み込む処理を追加します。特に**魚種データ**（`assets/fish.json`）は各魚のパラメータ（ID、名前、レア度、引きの強さ、出現深度範囲 等）を定義しています。これを`data`クレートで読み取り、ゲーム開始時に魚種リストを構築しましょう。具体的には、Serdeを使ってJSONをパースし、`Vec<FishType>`のような構造に落とし込みます。今後の拡張でレア魚出現や餌との相性ロジックを実装する際、このデータを参照できるようになります。
* **ゲームセーブ/ロード:** 要件6.6にあるように、ゲーム状態をRON形式で保存/復元する機能を実装します。釣りゲームではセッションが短い可能性もありますが、プレイ再開機能やスコア記録のためにセーブは有用です。ゲーム終了時（メニューの「Q」キー操作やプレイヤー脱落時）に現在のゲーム状態（プレイヤー位置・HP、所持品、マップ種など）を構造体としてシリアライズし、`save_<日時>.ron`に書き出します。ロードはタイトル画面で「続きから」選択時等に実装できますが、まずはセーブのみでも構いません。
* **結合とエラーハンドリング:** データ入出力処理では失敗の可能性があるため、以前用意した`GameError`型や`Result`を活用してエラー時にはログ出力・タイトル画面へフォールバックするなどの処理を入れます。例えばファイルが見つからない場合はエラーを返し、ゲーム側で捕捉して「セーブデータがありません」とログ表示して新規開始する、といった実装です。
* **確認:** 開発環境で実際に`fish.json`の内容が正しく読み込まれ、魚のパラメータ（特に**strength**値など）がゲーム内で反映されているか確認します。例えば、今まではダミー固定値だった`fish_strength`をデータ駆動に変更し、レア度や深度条件も試しに反映してみます（浅瀬では特定の魚のみスポーンする等）。セーブについては、一通りゲームを進めて終了時にセーブファイルが作成されること、そのファイルを手動で開いて中身（RON形式の構造体）が妥当か確認します。必要なら対応するロード処理も試験的に呼び出し、同じ状態で復元できるかテストします。

## ステップ12: テスト戦略の徹底と品質保証 (QA)

* **ユニットテストの充実:** 各機能モジュールごとに単体テストを充実させ、**ビジネスロジックの80%以上のカバレッジ**を目標にします。例えば:

  * `mapgen`のテスト: 与えたシードに対し生成されるマップのサイズや陸地/水域の割合が期待値範囲内か、浅瀬タイルが陸地周囲に配置されているか。
  * `ecology`のテスト: `spawn_fish`で魚が適切な水タイルに配置されるか、複数回呼んだ際に重複しないか。`update_fish`で魚の位置が有効範囲内で変化するか。
  * `fishing`のテスト: `TensionMeter`の計算ロジックが正しいか（例: `tension`が一定値以上で`is_line_broken()`がtrueになる等）、バイト確率計算関数が境界値で期待通りの結果を返すか。
  * その他: 各種ユーティリティ関数（例: 座標計算、衝突判定）もテスト。
* **ゴールデンマスター & スナップショット:** 前述の**マップ生成スナップショットテスト**に加え、安定した出力を持つ機能についてはスナップショット testing を導入します。例えば釣りテンションバーの一連の結果ログや、特定シナリオでの最終スコア計算結果など、将来の変更で不意に変わってはいけないものを記録し、テストで検証します。
* **統合テスト:** `cargo test --test`ディレクトリにシナリオテストを作成し、ゲームの主要な流れを自動検証します。例えば**擬似プレイ**として: 固定シードでマップ生成→プレイヤーを特定座標に移動→`c`でキャスト→強制的にバイト発生（乱数をモック/固定化）→テンションゲームを自動で成功させる（入力操作をモック化）→結果として魚がインベントリに入る、という一連の流れをコード上シミュレートし、期待通り最終状態になったか確認します。難易度は高いですが、可能な範囲でモックやシミュレーションを使い統合テストを実施することで、結合ポイント間の不具合を早期に検出できます。
* **CIパイプライン強化:** CI設定を最終形態に近づけます。に沿って、Lint（`cargo clippy -- -D warnings`で警告をエラー化）と全テスト実行（`cargo test --all`）を行い、さらにGitHub Actions上で**Ubuntu/Windows/macOS**のビルドを並行実行してクロスプラットフォームを担保します。WASMターゲットもビルド・テスト（`wasm-pack`経由）し、ヘッドレスブラウザでタイトル表示まで確認する手順を組み込みます。CIがパスすればビルド通過と機能テスト合格が保証される状態となり、安心してリファクタや機能追加ができる安定開発フェーズに入れます。
* **コード品質と拡張性確認:** 最後に非機能要件の観点で、パフォーマンス（60FPS相当のターン処理が維持できているか）、依存ライブラリやモジュール追加時の拡張性（新しいモジュール追加が3ファイル以内で完結する設計か）などを点検します。不必要に複雑な処理や構造になっていないか見直し、必要に応じてリファクタリングを行います。**env\_logger**によるログ出力レベル切替や、ゲーム内ログとコンソールログの分離も実装できていれば有益です（例えばデバッグ時は詳細ログをコンソールに出し、ユーザープレー時はゲーム画面内ログのみに抑えるなどフラグで制御）。こうした品質面の仕上げを行い、安定した開発基盤を完成させます。

以上、段階的に結合ポイントを押さえながら開発を進めるタスクリストを提示しました。各ステップでモックやスタブを活用しつつ部分的に統合テストを行うことで、大きな機能を実装する前に**接続箇所での不具合を早期発見**できます。また、シンプルでも効果的なテストとCIを導入することで、開発の各段階で品質を確保し、最終的に安定した開発フェーズへ移行できるでしょう。これらのステップは要件定義のマイルストーン（基盤→マップ→釣り→AI→仕上げ）にも対応しており、計画的に開発を進める指針となります。
